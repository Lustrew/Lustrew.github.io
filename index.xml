<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZW YE</title>
    <link>http://lucas-wye.github.io/</link>
      <atom:link href="http://lucas-wye.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>ZW YE</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Wed, 06 May 2020 12:15:17 +0800</lastBuildDate>
    <image>
      <url>http://lucas-wye.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>ZW YE</title>
      <link>http://lucas-wye.github.io/</link>
    </image>
    
    <item>
      <title>How to use search engine</title>
      <link>http://lucas-wye.github.io/post/howtosearch/</link>
      <pubDate>Wed, 06 May 2020 12:15:17 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/howtosearch/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Search engines are systems that enable users to search for documents on the World Wide Web.&lt;/li&gt;
&lt;li&gt;Popular examples include Yahoo!Search, Bing, Google, and Ask.com.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;特殊符号&#34;&gt;特殊符号&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;双引号&lt;/strong&gt;：把搜索词放在双引号中，代表&lt;strong&gt;完全匹配搜索&lt;/strong&gt;（顺序也必须完全匹配）&lt;/p&gt;
&lt;p&gt;eg: &amp;ldquo;浙江大学SCDA&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减号&lt;/strong&gt;：搜索不包含减号后面的词的页面，使用这个指令时减号前面必须是&lt;strong&gt;空格&lt;/strong&gt;，减号后面没有空格，紧跟着需要排除的词&lt;/p&gt;
&lt;p&gt;eg: 浙江大学 -学院&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;星号&lt;/strong&gt;：通配符&lt;/p&gt;
&lt;p&gt;eg: 浙*大学&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inurl&lt;/strong&gt;：查找网址中包含指定字符的页面&lt;/p&gt;
&lt;p&gt;eg: inurl:nice&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inanchor&lt;/strong&gt;：查找导入链接锚文字中包含搜索词的页面&lt;/p&gt;
&lt;p&gt;eg: inanchor:点击这里&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;intitle&lt;/strong&gt;: 查找页面title 中包含关键词的页面&lt;/p&gt;
&lt;p&gt;eg: intitle: 查老师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;filetype&lt;/strong&gt;：查找特定格式文件&lt;/p&gt;
&lt;p&gt;eg: filetype:pdf SCDA&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;site&lt;/strong&gt;: 搜索某个域名下的所有子路径&lt;/p&gt;
&lt;p&gt;eg: site: &lt;a href=&#34;http://www.zju.edu.cn&#34;&gt;www.zju.edu.cn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;快照功能&#34;&gt;快照功能&lt;/h2&gt;
&lt;p&gt;搜索引擎在收录网页时，对网页进行备份，存在自己的服务器缓存里，由于网页快照是存储在搜索引擎服务器中，所以查看网页快照的速度往往比直接访问网页要快&lt;/p&gt;
&lt;p&gt;eg: 高斯分布 site:zh.wikipedia.org&lt;/p&gt;
&lt;h2 id=&#34;特殊搜索&#34;&gt;特殊搜索&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;中文文献&lt;br&gt;

&lt;a href=&#34;http://xueshu.baidu.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;百度学术&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://cn.bing.com/academic?mkt=zh-CN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bing学术&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://scholar.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谷歌学术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;英文文献&lt;br&gt;

&lt;a href=&#34;https://cn.bing.com/academic?mkt=zh-CN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bing学术&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://scholar.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;谷歌学术&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://sci-hub.tw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sci-hub&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;http://ieeexplore.ieee.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IEEE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;编程相关&lt;br&gt;

&lt;a href=&#34;http://github.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://medium.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;medium&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;http://stackoverflow.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;深度搜索&#34;&gt;深度搜索&lt;/h2&gt;
&lt;p&gt;特殊的搜索工具可以搜索&lt;strong&gt;深网&lt;/strong&gt;的内容&lt;/p&gt;
&lt;p&gt;微信搜索 &lt;a href=&#34;https://weixin.sogou.com&#34;&gt;https://weixin.sogou.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Archive搜索引擎  &lt;a href=&#34;http://archive.org&#34;&gt;http://archive.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Wikihow 
&lt;a href=&#34;https://zh.wikihow.com/%e6%90%9c%e7%b4%a2%e6%b7%b1%e7%bd%91&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://zh.wikihow.com/搜索深网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;more &lt;a href=&#34;https://www.freebuf.com/news/137844.html&#34;&gt;https://www.freebuf.com/news/137844.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;
&lt;a href=&#34;https://www.zhihu.com/question/19847393&#34;&gt;https://www.zhihu.com/question/19847393&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/33188000&#34;&gt;https://zhuanlan.zhihu.com/p/33188000&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Matlab</title>
      <link>http://lucas-wye.github.io/post/matlab/</link>
      <pubDate>Wed, 06 May 2020 12:12:38 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/matlab/</guid>
      <description>&lt;p&gt;See 
&lt;a href=&#34;https://github.com/Lucas-Wye/academic-kickstart/blob/master/learning/matlab_share.pptx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to Ask Question</title>
      <link>http://lucas-wye.github.io/post/ask/</link>
      <pubDate>Mon, 27 Apr 2020 16:16:14 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/ask/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://www.catb.org/%7Eesr/faqs/smart-questions.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;See Detail From Here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LaTeX</title>
      <link>http://lucas-wye.github.io/post/latex/</link>
      <pubDate>Mon, 27 Apr 2020 16:12:48 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/latex/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;LaTeX（音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发。
利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。&lt;/li&gt;
&lt;li&gt;对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;方法一
从
&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;清华镜像源&lt;/a&gt;下载对应操作系统的Texlive软件包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装
sudo ./install-tl   
# 设置环境变量
# LaTeX
export TEX_HOME=/usr/local/texlive/2019
export PATH=$PATH:$TEX_HOME/bin/x86_64-linux
export INFOPATH=$INFOPATH:$TEX_HOME/texmf-dist/doc/info
export MANPATH=$MANPATH:$TEX_HOME/texmf-dist/doc/man      
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方法二
用docker安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 拉取镜像                    
sudo docker pull ubuntu:18.04
sudo docker run -it --rm ubuntu:18.04 bash
# 在镜像内操作
echo &amp;quot;deb http://mirrors.zju.edu.cn/ubuntu bionic main universe restricted multiverse
deb http://mirrors.zju.edu.cn/ubuntu bionic-security main universe restricted multiverse
deb http://mirrors.zju.edu.cn/ubuntu bionic-updates main universe restricted multiverse
deb http://mirrors.zju.edu.cn/ubuntu bionic-backports main universe restricted multiverse
deb-src http://mirrors.zju.edu.cn/ubuntu bionic main universe restricted multiverse
deb-src http://mirrors.zju.edu.cn/ubuntu bionic-security main universe restricted multiverse
deb-src http://mirrors.zju.edu.cn/ubuntu bionic-updates main universe restricted multiverse
deb-src http://mirrors.zju.edu.cn/ubuntu bionic-backports main universe restricted multiverse&amp;quot; &amp;gt; /etc/apt/sources.list
apt update
# 安装texlive
apt install texlive-full

# 保存镜像
docker ps
docker commit &amp;quot;刚刚安装的镜像&amp;quot; ubuntu-texlive

# 将本地的 /home/x/tex 挂载到镜像中的 /latex 目录
docker run -it -v /home/x/tex:/latex ubuntu-latex /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装-windows-字体&#34;&gt;安装 Windows 字体&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 创建 win 下字体专用文件夹
sudo mkdir /usr/share/fonts/winfonts

# 复制windows上的字体到/usr
sudo cp your_winfonts_dir /usr/share/fonts/winfonts 

# 进入字体文件夹
cd /usr/share/fonts/winfonts

# 修改访问权限
sudo chmod 744 *

# 回到主目录
cd ~

# 更新字体信息
sudo mkfontscale
sudo mkfontdir
sudo fc-cache -f -v
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;http://github.com/Lucas-Wye/Latex_template&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LaTeX模板&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;http://latexstudio.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LaTeX开源小屋&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SS</title>
      <link>http://lucas-wye.github.io/post/ss/</link>
      <pubDate>Mon, 27 Apr 2020 16:10:05 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/ss/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Shadowsocks（简称SS）是一種基於Socks5代理方式的加密傳輸协议，也可以指实现這個协议的各種开发包。&lt;/li&gt;
&lt;li&gt;目前套件使用Python、C、C++、C#、Go语言、Rust等程式語言开发，大部分主要实现（iOS平台的除外）採用Apache许可证、GPL、MIT許可證等多種自由軟體許可協定開放原始碼。&lt;/li&gt;
&lt;li&gt;Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并建立本地代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# Ubuntu  
sudo apt install shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 方法一                        
# Edit the configuration file
sudo vim /etc/shadowsocks-libev/config.json

# Edit the default configuration for debian
sudo vim /etc/default/shadowsocks-libev

# Start the service
sudo /etc/init.d/shadowsocks-libev start
## or
sudo systemctl start shadowsocks-libev

# 方法二
ss-local -c /path/to/config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;https://github.com/shadowsocksr-backup/shadowsocksr-libev/blob/master/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安装教程&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://www.sundabao.com/ubuntu%e4%bd%bf%e7%94%a8shadowsocks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;配置浏览器&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang</title>
      <link>http://lucas-wye.github.io/post/golang/</link>
      <pubDate>Mon, 27 Apr 2020 16:08:27 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/golang/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。&lt;/li&gt;
&lt;li&gt;Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。&lt;/li&gt;
&lt;li&gt;现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;从
&lt;a href=&#34;https://golang.google.cn/dl/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;此网站&lt;/a&gt;下载对应平台的编译器安装即可。&lt;/p&gt;
&lt;h2 id=&#34;设置国内代理&#34;&gt;设置国内代理&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;设置环境变量&#34;&gt;设置环境变量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# Golang
export GO=... # 安装位置
export PATH=$PATH:$GO/bin

export GOPATH=... # 指定一个本地位置
export PATH=$PATH:$GOPATH/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites. &lt;br&gt;

&lt;a href=&#34;https://www.runoob.com/go/go-tutorial.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go教程&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://www.w3cschool.cn/yqbmht/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;go web教程&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python</title>
      <link>http://lucas-wye.github.io/post/python/</link>
      <pubDate>Mon, 27 Apr 2020 16:05:43 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/python/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。&lt;/li&gt;
&lt;li&gt;Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。 像 Perl 语言一样, Python 源代码同样遵循 GPL(GNU General Public License) 协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;从
&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;清华镜像源&lt;/a&gt;下载对应平台的 anaconda/miniconda 安装即可。&lt;/p&gt;
&lt;h2 id=&#34;添加软件包下载镜像源&#34;&gt;添加软件包下载镜像源&lt;/h2&gt;
&lt;p&gt;编辑~/.condarc文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;channels:
    - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/
    - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/
    - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
- defaults
    show_channel_urls: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conda创建python虚拟环境&#34;&gt;conda创建python虚拟环境&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 查看当前存在哪些虚拟环境                                
conda env list  
conda info -e 
# 创建虚拟环境
conda create -n your_env_name python=X.X  # 版本选择：2.7、3.6等
# 激活环境
conda activate your_env_name
# 安装package到your_env_name
conda install -n your_env_name [package]
# 关闭虚拟环境
conda deactivate
# 删除虚拟环境
conda remove -n your_env_name --all
# 删除环境中的某个包
conda remove --name your_env_name package_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用包安装方法&#34;&gt;常用包安装方法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# tensorflow
conda install tensorflow
# pytorch(CPU)
conda install pytorch torchvision cpuonly -c pytorch
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;conda导出环境依赖&#34;&gt;conda导出环境依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;conda list -e &amp;gt; requirements.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jupyter-notebook&#34;&gt;Jupyter notebook&lt;/h3&gt;
&lt;p&gt;默认情况下，安装好 Anaconda 后打开 jupyter notebook, 访问本地 localhost:8888 即可。
但是如果要访问另一台机器，比如远端服务器上的 notebook, 即默认是不支持 ip addr:8888 的访问，需要额外配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 生成一个 notebook 配置文件
# 默认情况下,配置文件 ~/.jupyter/jupyter_notebook_config.py 并不存在
jupyter notebook --generate-config
# 生成密码
jupyter notebook password
# 修改配置文件 ～/.jupyter/jupyter_notebook_config.py
c.NotebookApp.ip = &#39;*&#39; # 允许任何IP访问
c.NotebookApp.password = u&#39;sha:...&#39; # 密码的哈希值
c.NotebookApp.open_browser = False 
c.NotebookApp.port = 8888 # 自行指定一个端口
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;添加多种环境&#34;&gt;添加多种环境&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 进入每个虚拟环境
conda activate env_name
conda install ipykernel
# 退出该虚拟环境
conda activate base
# 然后再将这个kernal添加到jupyter里面，NAME为自己取的环境名字
python -m ipykernel install --user --name NAME --display-name &amp;quot;NAME&amp;quot;
# 查看已有的kernels
cd ~/.local/share/jupyter/kernels  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;pip&#34;&gt;pip&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 导入依赖包                                
pip install -r requirements.txt 
# 只导出项目依赖包
pip install pipreqs
pipreqs ./
# 导出依赖包
pip freeze &amp;gt; requirements.txt
# 离线下载
pip download -d [DIR] -r requirements.txt 
# 离线安装
pip install --no-index --find-links=[DIR] -r requirements.txt  

# 更改镜像源
echo &amp;quot;[global]\nindex-url = http://mirrors.aliyun.com/pypi/simple/\n[install]\ntrusted-host = mirrors.aliyun.com&amp;quot; &amp;gt; ~/.pip/pip.conf 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;http://nbviewer.jupyter.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ipynb文件在线查看工具&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tmux</title>
      <link>http://lucas-wye.github.io/post/tmux/</link>
      <pubDate>Mon, 27 Apr 2020 16:04:15 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/tmux/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权&lt;/li&gt;
&lt;li&gt;使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Ubuntu
sudo apt-get install tmux
# MacOS
brew install tmux
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本操作&#34;&gt;基本操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 新建会话                                
tmux # 新建一个无名称的会话
tmux new -s demo # 新建一个名称为demo的会话
# 进入之前会话
tmux a # 默认进入第一个会话
tmux a -t demo # 进入到名称为demo的会话
# 离开会话
ctrl+b+d
# 关闭会话
tmux kill-session -t demo # 关闭demo会话
tmux kill-server # 关闭服务器，所有的会话都将关闭
# 查看会话
tmux list-session # 查看所有会话
tmux ls # 查看所有会话，提倡使用简写形式

# 垂直分屏
ctrl+b+% 
# 水平分屏
ctrl+b+\&amp;quot; 
# 根据按箭方向选择切换到某个pane。
ctrl+b+Up|Down|Left|Right 

# 滚屏
# 要进入copy-mode，即PREFIX+[，然后就可以用上下键来滚动屏幕，配置了vi快捷键模式，
# 就可以像操作vi一样来滚动屏幕，非常的方便。退出直接按‘q’键即可。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;http://louiszhai.github.io/2017/09/30/tmux/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tmux使用手册&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java</title>
      <link>http://lucas-wye.github.io/post/java/</link>
      <pubDate>Mon, 27 Apr 2020 15:59:14 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/java/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。 Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.oracle.com/technetwork/java/javase/downloads/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;下载JDK&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://www.jetbrains.com/idea/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IntelliJ IDEA下载&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 配置环境变量                                
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144  # 这里换成自己的jdk目录
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;usage-of-adbandroid-debug&#34;&gt;Usage of adb(Android Debug)&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 卸载系统软件
adb shell
pm list package
pm uninstall -k --user 0 package_name
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Vi/Vim/NeoVim</title>
      <link>http://lucas-wye.github.io/post/vi_vim/</link>
      <pubDate>Mon, 27 Apr 2020 15:36:39 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/vi_vim/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。&lt;/li&gt;
&lt;li&gt;vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。&lt;/li&gt;
&lt;li&gt;Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;file-operation&#34;&gt;File Operation&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;:wq&lt;/td&gt;
&lt;td&gt;存盘退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:q!&lt;/td&gt;
&lt;td&gt;退出不保存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:saveas &amp;lt;path/to/file&amp;gt;&lt;/td&gt;
&lt;td&gt;另存为 &amp;lt;path/to/file&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:qa!&lt;/td&gt;
&lt;td&gt;强行退出所有的正在编辑的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:bn 和 :bp&lt;/td&gt;
&lt;td&gt;切换下一个或上一个文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:w !sudo tee %&lt;/td&gt;
&lt;td&gt;保存正在编辑的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:n&lt;/td&gt;
&lt;td&gt;move to next file&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:rew&lt;/td&gt;
&lt;td&gt;回到第一个文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:edit &lt;Filename&gt;&lt;/td&gt;
&lt;td&gt;打开新文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;cursor-movement&#34;&gt;Cursor movement&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;hjkl&lt;/td&gt;
&lt;td&gt;move&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;pattern&gt;&lt;/td&gt;
&lt;td&gt;搜索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;pattern&gt;&lt;/td&gt;
&lt;td&gt;搜索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;匹配括号移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;搜索并移动到某个字符前&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;到某个字符前的第一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:N&lt;/td&gt;
&lt;td&gt;到第N行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gg&lt;/td&gt;
&lt;td&gt;到第一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;到最后一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[n] G&lt;/td&gt;
&lt;td&gt;go to last line or line [n]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w/W&lt;/td&gt;
&lt;td&gt;到下一个单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e/E&lt;/td&gt;
&lt;td&gt;到下一个单词的结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;到上一个单词的开头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;beginning of current line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;end of current line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;beginning of text on current line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;CR&gt; F/B&lt;/td&gt;
&lt;td&gt;move screen&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;CR&gt; D/U&lt;/td&gt;
&lt;td&gt;move half screen&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;inserting-text&#34;&gt;Inserting text&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;前插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;后插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;insert text at beginning of line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;append text at end of line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;在当前行后插入一个新行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;在当前行前插入一个新行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;deleting-text&#34;&gt;Deleting text&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;删除当前行光标后所有内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;删当前光标的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;删当前光标前的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;changing-commands&#34;&gt;Changing commands&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;undo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;CR&gt; r&lt;/td&gt;
&lt;td&gt;redo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;repeat last operation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;后粘贴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;P&lt;/td&gt;
&lt;td&gt;前粘贴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;复制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s/S&lt;/td&gt;
&lt;td&gt;substitute&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;change case of character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;join current line and next line&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;split-windows&#34;&gt;Split windows&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;:split/vsplit&lt;/td&gt;
&lt;td&gt;创建分屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;CR&gt; w + 方向&lt;/td&gt;
&lt;td&gt;切换分屏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;command-line-mode&#34;&gt;Command line mode&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;:![cmd]&lt;/td&gt;
&lt;td&gt;暂时退出命令行执行cmd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:set all&lt;/td&gt;
&lt;td&gt;display all option settings&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:[Addr]s/old expr/new string/[g]&lt;/td&gt;
&lt;td&gt;替换当前行/Addr的old expr为new string,[g]全局替换，否则只替换第一个 ｜&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;CR&gt; p/n&lt;/td&gt;
&lt;td&gt;自动补齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;CR&gt; +/-&lt;/td&gt;
&lt;td&gt;改变尺寸&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;visual模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;v-line模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;CR&gt; v&lt;/td&gt;
&lt;td&gt;v-block模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:normal &lt;Command&gt;&lt;/td&gt;
&lt;td&gt;可视化模式下执行命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;qa&lt;/td&gt;
&lt;td&gt;录制宏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ci + &amp;quot;&lt;/td&gt;
&lt;td&gt;删除引号之中的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tabe&lt;/td&gt;
&lt;td&gt;打开新的标签页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+/-tabnext&lt;/td&gt;
&lt;td&gt;切换标签页&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;regular-expression&#34;&gt;Regular expression&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;match any single character at the indicated position&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;match any string of zero or more characters&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[abc&amp;hellip;]&lt;/td&gt;
&lt;td&gt;match any of the enclosed characters&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[a-e]&lt;/td&gt;
&lt;td&gt;match any characters in the range a,b,c,d,e&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[!def]&lt;/td&gt;
&lt;td&gt;match any characters not one of the enclosed characters, sh/bash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{abc,bcd,cde}&lt;/td&gt;
&lt;td&gt;match any set of characters separated by comma (,) (no spaces), bash/csh&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;home directory of the current user, bash/csh&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;~ user&lt;/td&gt;
&lt;td&gt;home directory of the specified user, bash/csh&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;match any single character except newline&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[^abc]&lt;/td&gt;
&lt;td&gt;match any character NOT in the enclosed set&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^exp&lt;/td&gt;
&lt;td&gt;regular expression must start at the beginning of the line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;exp$&lt;/td&gt;
&lt;td&gt;regular expression must end at the end of the line&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;treat the next character literally 转义字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xy*z&lt;/td&gt;
&lt;td&gt;xy开头，z结尾的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;plug&#34;&gt;Plug&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/junegunn/vim-plug&#34;&gt;https://github.com/junegunn/vim-plug&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;vimrc&#34;&gt;.vimrc&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/Lucas-Wye/academic-kickstart/blob/master/learning/.vimrc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;.vimrc&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;neovimhttpsneovimio&#34;&gt;
&lt;a href=&#34;https://neovim.io&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NeoVim&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使用vim配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ln -s ~/.vim ~/.config/nvim
ln -s ~/.vimrc ~/.config/nvim/init.vim


## More
See detail in these websites.  
[Vi/Vim教程](https://www.runoob.com/linux/linux-vim.html)  
[简明 VIM 练级攻略](https://coolshell.cn/articles/5426.html)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Website</title>
      <link>http://lucas-wye.github.io/post/website/</link>
      <pubDate>Fri, 27 Mar 2020 16:23:44 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/website/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;收录了一些目前的常用网站&lt;/li&gt;
&lt;li&gt;Here are some useful websites. Hope these will help you.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;repo&#34;&gt;Repo&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://zjusct.github.io/archives/&#34;&gt;https://zjusct.github.io/archives/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://pmpml.github.io/PMPML16/&#34;&gt;https://pmpml.github.io/PMPML16/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://github.com/momodel/AIClub&#34;&gt;https://github.com/momodel/AIClub&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://machine-learning-and-security.github.io/&#34;&gt;https://machine-learning-and-security.github.io/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://ying-zhang.github.io/misc/2016/we-love-paper/&#34;&gt;https://ying-zhang.github.io/misc/2016/we-love-paper/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://daiwk.github.io/posts/dl-federated-learning.html&#34;&gt;https://daiwk.github.io/posts/dl-federated-learning.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;paper&#34;&gt;Paper&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/&#34;&gt;https://arxiv.org/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://scholar.google.com/&#34;&gt;https://scholar.google.com/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.arxiv-sanity.com/&#34;&gt;http://www.arxiv-sanity.com/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://scholar.chongbuluo.com&#34;&gt;http://scholar.chongbuluo.com&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://libweb.zju.edu.cn/libweb/&#34;&gt;http://libweb.zju.edu.cn/libweb/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://ieeexplore.ieee.org/Xplore/home.jsp&#34;&gt;https://ieeexplore.ieee.org/Xplore/home.jsp&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://paperpass.com/&#34;&gt;https://paperpass.com/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://dsa.dayainfo.com/&#34;&gt;http://dsa.dayainfo.com/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://www.myhuiban.com/&#34;&gt;http://www.myhuiban.com/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.ccf.org.cn/xspj/gyml/&#34;&gt;https://www.ccf.org.cn/xspj/gyml/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://jianying.space/conference-ranking.html&#34;&gt;http://jianying.space/conference-ranking.html&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://faculty.cs.tamu.edu/guofei/sec_conf_stat.htm&#34;&gt;http://faculty.cs.tamu.edu/guofei/sec_conf_stat.htm&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kali</title>
      <link>http://lucas-wye.github.io/post/kali/</link>
      <pubDate>Wed, 16 Oct 2019 16:02:51 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/kali/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Kali Linux是基于Debian的Linux发行版， 设计用于数字取证操作系统。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版。&lt;/li&gt;
&lt;li&gt;Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、John the Ripper，以及Aircrack-ng；用户可通过硬盘、live CD或live USB运行Kali Linux。Kali Linux既有32位和64位的镜像。可用于x86 指令集。同时还有基于ARM架构的镜像，可用于树莓派和三星的ARM Chromebook。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 从Docker安装
docker pull kalilinux/kali-linux-docker
# 运行
docker run -t -i kalilinux/kali-linux-docker /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###设置镜像源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改/etc/apt/source.list
# 中科大
deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
 
# 阿里云
deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
 
# 清华
deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free
deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free
 
# 浙大
deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free
deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free
 
# 官方源
deb http://http.kali.org/kali kali-rolling main non-free contrib
deb-src http://http.kali.org/kali kali-rolling main non-free contrib
 
deb http://mirrors.163.com/debian/ jessie main non-free contrib
deb http://mirrors.163.com/debian/ jessie-updates main non-free contrib
deb http://mirrors.163.com/debian/ jessie-backports main non-free contrib
deb-src http://mirrors.163.com/debian/ jessie main non-free contrib
deb-src http://mirrors.163.com/debian/ jessie-updates main non-free contrib
deb-src http://mirrors.163.com/debian/ jessie-backports main non-free contrib
deb http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib
deb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;https://www.kali.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;kali官网&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>http://lucas-wye.github.io/post/docker/</link>
      <pubDate>Wed, 16 Oct 2019 16:00:33 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/docker/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# Ubuntu                                
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# 建立docker组
sudo groupadd docker
# 将当前用户加入docker组
sudo usermod -aG docker $USER

# 卸载本机所有的镜像、容器、卷以及配置文件
sudo rm -rf /var/lib/docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本命令&#34;&gt;基本命令&lt;/h2&gt;
&lt;p&gt;获取镜像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker pull [user name]/[repo name]:[tag name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dockerfile example&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Dockerfile创建镜像
FROM ubuntu:18.04
ENV LANG C.UTF-8
RUN echo &amp;quot;deb http://mirrors.zju.edu.cn/ubuntu bionic main universe restricted multiverse\ndeb http://mirrors.zju.edu.cn/ubuntu bionic-security main universe restricted multiverse\ndeb http://mirrors.zju.edu.cn/ubuntu bionic-updates main universe restricted multiverse\ndeb http://mirrors.zju.edu.cn/ubuntu bionic-backports main universe restricted multiverse\ndeb-src http://mirrors.zju.edu.cn/ubuntu bionic main universe restricted multiverse\ndeb-src http://mirrors.zju.edu.cn/ubuntu bionic-security main universe restricted multiverse\ndeb-src http://mirrors.zju.edu.cn/ubuntu bionic-updates main universe restricted multiverse\ndeb-src http://mirrors.zju.edu.cn/ubuntu bionic-backports main universe restricted multiverse&amp;quot; &amp;gt; /etc/apt/sources.list
# RUN ...
# for pip 
# RUN echo &amp;quot;[global]\nindex-url = http://mirrors.aliyun.com/pypi/simple/\n[install]\ntrusted-host = mirrors.aliyun.com&amp;quot; &amp;gt; ~/.pip/pip.conf
# for conda
# RUN echo &amp;quot;channels:\n  - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\n  - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n  - defaults\nshow_channel_urls: true&amp;quot; &amp;gt; ~/.condarc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
-i: 以交互模式运行容器，通常与 -t 同时使用
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用
-v: 绑定一个卷，格式为：本机绑定目录:容器内部绑定目录
-d: 后台运行容器，并返回容器ID
-P: 随机端口映射，容器内部端口随机映射到主机的高端口
-p: 指定端口映射，格式为：主机(宿主)端口:容器端口
-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项
--name: 对所新建容器进行命名
--rm: 容器终止后，自动删除容器文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 列出容器
docker container ls -a 
# 查看容器ID
docker ps -a
# 重新启动已被终止的指定容器
docker start [CONTAINER ID]

# 终止容器
docker stop [CONTAINER NAME/ID]
# 若是利用 -it 在容器内部进行操作，仅需输入 exit 即可

# 删除容器
docker kill [CONTAINER NAME/ID]
# 若想将所有容器删除
docker container prune

# 列出镜像
docker images
# 重命名镜像
docker tag [old REPOSITORY]:[old TAG] or [IMAGE ID] [new REPOSITORY]:[new TAG]
# 删除镜像
docker rmi [IMAGE]

# 存出镜像
docker save -o [xx.tar] [REPOSITORY]:[TAG]

# 载入镜像
sudo docker load --input [镜像文件]

# 更新镜像
docker commit [OPTIONS] [IMAGE ID] [new REPOSITORY]:[new TAG]
# -m: 提交的描述信息
# -a: 指定镜像作者
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;https://www.runoob.com/docker/docker-container-usage.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker教程&lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://wiki.jikexueyuan.com/project/docker-technology-and-combat/save_load.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker学习笔记&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GCC</title>
      <link>http://lucas-wye.github.io/post/gcc/</link>
      <pubDate>Wed, 16 Oct 2019 15:57:07 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/gcc/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;GCC编译器也称为Linux GCC命令，它有很多选项。GCC编译器是Linux下最常用的编译器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# MacOS安装Xcode工具链                                
xcode-select --install
# Ubuntu
sudo apt install gcc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gcc -c filename.c # compile only, produce .o
gcc -g # compile for debugging
gcc -o filename.o # 
gcc -O 1,2,3,4,s,fast # for optimization level
gcc -Ipathname
gcc -Dsymbol # define preprocessor symbol
gcc -Ldirectory # add directory to the library search path
gcc -lxyz # link with library libxyz.a or libxyz.so
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gdb&#34;&gt;gdb&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gdb BINARY_FILE
list
br 8 # breakpoint in line 8
run
print value 
next
where
help
quit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;make&#34;&gt;make&lt;/h2&gt;
&lt;p&gt;(1)Predefined Macros&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AS - assembler (as)
CC - C compiler command (cc)
FC - Fortran compiler command (fc)
CPP - C++ preprocessing command ($(CC) -E)
CXX - C++ compiler command (g++)
CFLAGS - C compiler option flags (e.g. -g)
FFLAGS - Fortran compiler option flags (e.g. -g)
LDFLAGS - Linking option flags (e.g. –L /usr/share/lib)
LDLIBS – Linking libraries (e.g. -lm) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)Special Internal Macros&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$* # The basename of the current target
$&amp;lt; # The name of a dependency file, as we see on last page
$@ # The name of the current target.
$? # The list of dependencies that are newer than the target.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;https://blog.csdn.net/gatieme/article/details/51671430&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;more of gdb&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>http://lucas-wye.github.io/post/git/</link>
      <pubDate>Wed, 16 Oct 2019 15:30:21 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/git/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。&lt;/li&gt;
&lt;li&gt;Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/li&gt;
&lt;li&gt;Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;git本地操作&#34;&gt;git本地操作&lt;/h2&gt;
&lt;p&gt;(1)创建空仓库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)添加文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add FILE_NAME
git commit -m YOUR_COMMENT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3)查看状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(4)版本回退&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100
git reset --hard HEAD^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(5)记录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log # 当前分支
git reflog # 所有分支信息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(6)删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm test.txt
git rm test.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;git远程&#34;&gt;git远程&lt;/h2&gt;
&lt;p&gt;(1)创建远程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;YOUR_EMAIL&amp;quot;
git config --global user.name &amp;quot;YOUR_NAME&amp;quot;
git config --global user.email &amp;quot;YOUR_EMAIL&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(2)推送至github&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin git@github.com:xxx/xxx.git 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(3)第一次推送&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push -u origin master 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(4)后续推送&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(5)克隆&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:xxx/xxx.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(6)拉取远程代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 取回远程主机某个分支的更新，再与本地的指定分支合并
git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(7)删除git项目所有提交历史&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 创建新分支
git checkout --orphan latest_branch
# 添加所有文件
git add .
# commit代码
git commit -m YOUR_COMMENT
# 删除原来的master分支
git branch -D master
# 重命名为master
git branch -m master
# 推送到远程仓库
git push -f origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(8).git垃圾回收&lt;br&gt;
Git仓库越来越臃肿，大多数版本控制系统存储的是一组初始文件，以及每个文件随着时间的演进而逐步积累起来的差异；&lt;br&gt;
而Git则会把文件的每一个差异化版本都记录在案。这意味着，即使你只改动了某个文件的一行内容，Git也会生成一个全新的对象来存储新的文件内容。 &lt;br&gt;
对象碎片：如果你改动了一个很大的文件，git会为这个文件生成了一个很大的Blob对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd .git
du -ah  # 查看文件大小
git gc --prune=now # 垃圾回收
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上，并不需要手动调用 gc 命令。每当碎片对象过多，或者你向远端服务器发起推送的时候，git 就会自动执行一次打包过程。
(9)git更改远程库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查询当前远程库
git remote -v
# 更改远程库
git remote origin set-url &amp;lt;仓库地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;submodule&#34;&gt;submodule&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 添加子仓库
git submodule add &amp;lt;仓库地址&amp;gt; &amp;lt;本地路径&amp;gt;
# 检出子仓库
git submodule init # 初始化本地配置文件
git submodule update # 检出父仓库列出的commit 
## 或者
git submodule update --init --recursive
# 递归克隆
git clone &amp;lt;仓库地址&amp;gt; --recursive
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;https://www.runoob.com/git/git-tutorial.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;git教程&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>http://lucas-wye.github.io/post/linux/</link>
      <pubDate>Wed, 16 Oct 2019 15:19:22 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/linux/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;control-key&#34;&gt;Control Key&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;^U           cancel line
^C           cancel operation
^S           pause display
^Q           restart display
^A           光标移到行首
^E           光标移到行末
^K           清除至当前行尾
^V           treat following control character as normal character
option+方向键 以单词为单位移动
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;add-user-and-change-password&#34;&gt;Add user and Change password&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;adduser UserName
# 添加root权限
usermod -g sudo UserName
passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;infomation&#34;&gt;Infomation&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;who
who am i
whoami
env # show environment variables
alias # rename commane ( alias l=&#39;ls -CF&#39;)
man # manual sections
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;file-maintenance&#34;&gt;File Maintenance&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# r = 4, w = 2, x = 1
chmod
umask # set in startup files for the account to masks out permissions, umask numbers added to desired permission number equals 7.
chgrp # change the group of the file
chown # change the owner of a file 

# 查看当前目录文件大小
# 方法一：列出当前目录下每个文件的大小，同时也会给出当前目录下所有文件大小总和
ls -lht

# 方法二：列出当前文件夹下所有文件对应的大小，把*替换为具体的文件名，会给出具体文件的大小
du -sh *

# 删除文件中的空行
cat YOUR_FILE | sed -e &#39;/^$/d&#39;

# conditions
-r return true (1) if it exists and is readable, otherwise return false (0)
-w true if it exists and is writable
-x true if it exists and is executable
-f true if it exists and is a regular file (or for csh, exists and is not a directory)
-d true if it exists and is a directory
-e true if the file exists
-o true if the user owns the file
-z true if the file has zero length (empty)

# 对Exfat文件系统支持
sudo apt install exfat-utils

# 打包
tar -cvf  YOUR_FILE.tar YOUR_FILE # 仅打包 
tar -zcvf YOUR_FILE.tar.gz YOUR_FILE # gzip压缩
tar -jcvf YOUR_FILE.tar.bz2 YOUR_FILE # bzip2压缩

# 查看文件
tar -tvf YOUR_FILE.tar
tar -ztvf YOUR_FILE.tar.gz
tar -jtvf YOUR_FILE.tar.bz2

# 解包
tar -xvf YOUR_FILE.tar
tar -zxvf YOUR_FILE.tar.gz
tar -jxvf YOUR_FILE.tar.bz2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;find-and-search&#34;&gt;find and search&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 查找24小时内修改过的文件
find ./ -mtime 0 
grep -nHR &amp;quot;search string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;process&#34;&gt;process&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ps
ps -ef
kill -9 PID
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bash-executes-order&#34;&gt;Bash executes order&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# login shell executes order:  
/etc/profile -&amp;gt; 
~/.bash/_profile -&amp;gt;  
~/.bash_login -&amp;gt; 
~/.profile

# non-login shell executes:  
/etc/bashrc -&amp;gt; 
~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;history&#34;&gt;History&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;history
!598 # 执行第598条命令
sudo !! # 以root执行上一条命令
history  | awk &#39;{a[$2]++}END{for(i in a){print a[i] &amp;quot; &amp;quot; i}}&#39; | sort -rn | head # 统计情况
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cpu&#34;&gt;CPU&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 总核数 = 物理CPU个数 x 每颗物理CPU的核数 
# 总逻辑CPU数 = 物理CPU个数 x 每颗物理CPU的核数 x 超线程数

# 物理CPU个数
cat /proc/cpuinfo| grep &amp;quot;physical id&amp;quot;| sort| uniq| wc -l

# 每个物理CPU中core的个数(即核数)
cat /proc/cpuinfo| grep &amp;quot;cpu cores&amp;quot;| uniq

# 逻辑CPU的个数
cat /proc/cpuinfo| grep &amp;quot;processor&amp;quot;| wc -l

# CPU型号
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c

# CPU的负载，返回1、5、15分钟内的负载情况
uptime 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;内存&#34;&gt;内存&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cat /proc/meminfo
free
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;磁盘&#34;&gt;磁盘&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 硬盘信息
fdisk -l 
# 查看磁盘IO的性能
iostat -x 10
# 挂载硬盘到某个文件夹
sudo mount /dev/sda /your/path
# 查看硬盘挂载信息
df -h
# 取消挂载
sudo umount /your/path
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除ppa源&#34;&gt;删除ppa源&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /etc/apt/sources.list.d/ # 找到关于源的文件,删除即可
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看中文字体&#34;&gt;查看中文字体&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;fc-list:lang=zh-cn
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;io-redirection-and-piping&#34;&gt;I/O Redirection and Piping&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# stdin: 0, stdout: 1, stderr: 2
|                      管道
&amp;gt;                      stdout重定向到file
&amp;gt;&amp;gt;                     stdout重定向到file(不覆盖)
&amp;lt;                      stdin从file重定向
tee                    复制stdout
&amp;gt;/dev/null             直接扔掉stdout
1&amp;gt;file1 2&amp;gt;file2        stdout to file1, stderr to file2
&amp;gt;file 2&amp;gt;&amp;amp;1             redirect stdout and stderr to file
2&amp;gt;&amp;amp;1 | tee             将stderr和stdout输出到文件的同时在屏幕上输出
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;开机进入命令行&#34;&gt;开机进入命令行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo systemctl set-default multi.user # 进入命令行
sudo systemctl set-default graph...   # 进入图形界面
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;terminal设置代理&#34;&gt;terminal设置代理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# MacOS: 1087, other: 1080
export http_proxy=http://127.0.0.1:1087
export https_proxy=http://127.0.0.1:1087
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ubuntu设置窗口键在左侧&#34;&gt;Ubuntu设置窗口键在左侧&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gsettings set org.gnome.desktop.wm.preferences button-layout &#39;close,minimize,maximize:&#39;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>OpenMP使用方法</title>
      <link>http://lucas-wye.github.io/post/openmp/</link>
      <pubDate>Fri, 04 Oct 2019 15:03:25 +0800</pubDate>
      <guid>http://lucas-wye.github.io/post/openmp/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;OpenMP是由OpenMP Architecture Review Board牵头提出的，并已被广泛接受的，用于共享内存并行系统的多线程程序设计的一套编译指令 (Compiler Directive)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;See detail at 
&lt;a href=&#34;https://en.wikipedia.org/wiki/OpenMP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;openmp-programming-example&#34;&gt;OpenMP Programming Example&lt;/h2&gt;
&lt;p&gt;Here is a C program using OpenMP.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;omp.h&amp;gt;

int main(void) {
    const int n = 10;
    int arr[n];

    #pragma omp parallel for  
    for(int i = 0;i &amp;lt; n;i++) {
        arr[i] = i;
        printf(&amp;quot;%d\n&amp;quot;,i);
    }

    for(int j = 0;j &amp;lt; n;j++){
        printf(&amp;quot;%d\n&amp;quot;,arr[j]);
    }

    return 0;      
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;more-example&#34;&gt;More Example&lt;/h2&gt;
&lt;p&gt;See detail in these websites.&lt;br&gt;

&lt;a href=&#34;https://zhuanlan.zhihu.com/p/51173703&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenMP并行开发（C++） &lt;/a&gt;&lt;br&gt;

&lt;a href=&#34;https://blog.csdn.net/drzhouweiming/article/details/1175848&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenMP并行程序设计（二）&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
