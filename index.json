[{"authors":["admin"],"categories":null,"content":"I am a bachelor student of Electronic Engineering at the College of Information Science \u0026amp; Electronic Engineering (ISEE), Zhejiang University (ZJU).\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"http://lucas-wye.github.io/author/zw-ye/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/zw-ye/","section":"authors","summary":"I am a bachelor student of Electronic Engineering at the College of Information Science \u0026amp; Electronic Engineering (ISEE), Zhejiang University (ZJU).","tags":null,"title":"ZW YE","type":"authors"},{"authors":[],"categories":[],"content":" A computer network is a digital telecommunications network which allows nodes to share resources. In computer networks, computing devices exchange data with each other using connections (data links) between nodes.  Commands ping domainname hostname cat /etc/hosts # ip address sudo systemctl restart NetworkManager # hosts生效 cat /etc/resolv.conf # dns server ip # TCP/IP interface configuration and routing utility ifconfig # configure a network interface route # show / manipulate the IP routing table netstat # show network status (network connections, routing tables, interface statistics, masquerade connections, and multicast memberships) sudo ping ip地址 -i 0.01 -s 65500 # 每0.01秒给ip地址对应的机器发送65500字节的数据包  Useful Remote Connection Utilities • ftp [options] host, transfer file(s) using file transfer protocol\n• telnet [host [port]], communicate with host using telnet protocol\n• ssh, remote login or remote execution using secure shell\n• rcp/scp, remotely copy files from this machine to another machine\n• rsync, smartly copy files over network after checking contents\n• curl, transfer a URL via HTTP, FTP, IMAP, etc\n• wget, download files over the Internet via HTTP or FTP\n• lynx/links, text-mode (mini) web browser\naria2 (1)Install\n# Ubuntu sudo apt-get install aria2 # CentOS yum install aria2  (2)Usage\n# 在命令后附加地址即可 aria2c \u0026quot;url\u0026quot; # 分段下载，利用 aria2 的分段下载功能可以加快文件的下载速度 # 使用 2 个连接来下载该文件，s的参数值介于 1~5 之间 aria2c -s 2 \u0026quot;url\u0026quot; # 断点续传，在命令中使用 c 选项可以断点续传文件 aria2c -c \u0026quot;url\u0026quot;  ssh # 安装 SSH(Secure Shell) 服务以提供远程管理服务 sudo apt install openssh-server # 启动ssh服务 /etc/init.d/ssh start sudo service ssh start # 检测是否已启动 ps -e | grep ssh ## SSH远程登录 ssh username@192.168.0.1 # 将文件/文件夹从远程机下载到本地(scp) scp -r username@192.168.0.1:/home/username/remotefile.txt . # 设置公钥登录 # (1)复制本地的公钥 cat ~/.ssh/id_rsa.pub # (2)在远程机器上写入复制的公钥 vim ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys # (3)远程机器授权公钥登录 sudo echo \u0026quot;PubkeyAuthentication yes\u0026quot; \u0026gt;\u0026gt; /etc/ssh/sshd_config # (4)重启ssh服务 sudo systemctl restart sshd.service # .ssh/config example Host {HOSTNAME} HostName {IP} User {Username} ssh HOSTNAME  curl  client URL tool  (1)不带有任何参数时，发出 GET 请求\ncurl https://www.example.com  (2)-A指定User-Agent，默认用户代理字符串是curl/[version]\ncurl -A 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36' https://google.com  (3)-b 参数用来向服务器发送 Cookie\n# 生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie curl -b 'foo=bar' https://google.com  (4)-d 参数用于发送 POST 请求的数据体\ncurl -d'login=emma＆password=123'-X POST https://google.com/login # `--data-urlencode` 等同于 `-d` # 发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码  (5)-G 参数用来构造 URL 的查询字符串\n# 实际请求的 URL 为https://google.com/search?q=kitties\u0026amp;count=20 curl -G -d 'q=kitties' -d 'count=20' https://google.com/search  (6)-H 参数添加 HTTP 请求的标头\ncurl -H 'Accept-Language: en-US' https://google.com curl -d '{\u0026quot;login\u0026quot;: \u0026quot;emma\u0026quot;, \u0026quot;pass\u0026quot;: \u0026quot;123\u0026quot;}' -H 'Content-Type: application/json' https://google.com/login  (7) -i 参数打印出服务器回应的 HTTP 标头\n# 先输出服务器回应的标头，然后空一行，再输出网页的源码 curl -i https://www.example.com  (8)-o 参数将服务器的回应保存成文件，等同于wget命令\ncurl -o example.html https://www.example.com # `-O` 参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。 curl -O https://www.example.com/foo/bar.html # 通过添加 `-C` 继续对该文件进行下载，已经下载过的文件不会被重新下载 curl -C -O http://www.gnu.org/software/gettext/manual/gettext.html  More See detail in these websites.\nnmcli用法\n","date":1590807003,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590807003,"objectID":"29a43482b00560917ae50cb1e063ac48","permalink":"http://lucas-wye.github.io/post/cli_net_work/","publishdate":"2020-05-30T10:50:03+08:00","relpermalink":"/post/cli_net_work/","section":"post","summary":"A computer network is a digital telecommunications network which allows nodes to share resources. In computer networks, computing devices exchange data with each other using connections (data links) between nodes.","tags":[],"title":"Network","type":"post"},{"authors":[],"categories":[],"content":" Search engines are systems that enable users to search for documents on the World Wide Web. Popular examples include Yahoo!Search, Bing, Google, and Ask.com.  特殊符号 双引号：把搜索词放在双引号中，代表完全匹配搜索（顺序也必须完全匹配）\neg: \u0026ldquo;浙江大学SCDA\u0026rdquo;\n减号：搜索不包含减号后面的词的页面，使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词\neg: 浙江大学 -学院\n星号：通配符\neg: 浙*大学\ninurl：查找网址中包含指定字符的页面\neg: inurl:nice\ninanchor：查找导入链接锚文字中包含搜索词的页面\neg: inanchor:点击这里\nintitle: 查找页面title 中包含关键词的页面\neg: intitle: 查老师\nfiletype：查找特定格式文件\neg: filetype:pdf SCDA\nsite: 搜索某个域名下的所有子路径\neg: site: www.zju.edu.cn\n快照功能 搜索引擎在收录网页时，对网页进行备份，存在自己的服务器缓存里，由于网页快照是存储在搜索引擎服务器中，所以查看网页快照的速度往往比直接访问网页要快\neg: 高斯分布 site:zh.wikipedia.org\n特殊搜索  中文文献\n百度学术\nbing学术\n谷歌学术 英文文献\nbing学术\n谷歌学术\nSci-hub\nIEEE 编程相关\ngithub\nmedium\nstackoverflow  深度搜索 特殊的搜索工具可以搜索深网的内容\n微信搜索 https://weixin.sogou.com\nArchive搜索引擎 http://archive.org\nWikihow https://zh.wikihow.com/搜索深网\nmore https://www.freebuf.com/news/137844.html\nMore See detail in these websites.\nsearch.pdf\n搜索引擎有哪些常用技巧\n深网搜索引擎\n","date":1588738517,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588738517,"objectID":"a64273c0aafeee22766b03e185da08b4","permalink":"http://lucas-wye.github.io/post/howtosearch/","publishdate":"2020-05-06T12:15:17+08:00","relpermalink":"/post/howtosearch/","section":"post","summary":"Search engines are systems that enable users to search for documents on the World Wide Web","tags":[],"title":"How to use search engine","type":"post"},{"authors":[],"categories":[],"content":"See here\n","date":1588738358,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588738358,"objectID":"e76f3cffcc15d29880a7c0f15c126b0b","permalink":"http://lucas-wye.github.io/post/matlab/","publishdate":"2020-05-06T12:12:38+08:00","relpermalink":"/post/matlab/","section":"post","summary":"MATLAB ® combines a desktop environment tuned for iterative analysis and design processes with a programming language that expresses matrix and array mathematics directly","tags":[],"title":"Matlab","type":"post"},{"authors":[],"categories":[],"content":" See Detail From Here\n","date":1587975374,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587975374,"objectID":"d67d50e909ee90eaa4af6af3badd74b8","permalink":"http://lucas-wye.github.io/post/ask/","publishdate":"2020-04-27T16:16:14+08:00","relpermalink":"/post/ask/","section":"post","summary":"See Detail From Here","tags":[],"title":"How to Ask Question","type":"post"},{"authors":[],"categories":[],"content":" LaTeX（音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发。 利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。 对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。  Install 方法一 从 清华镜像源下载对应操作系统的Texlive软件包\n# 安装 sudo ./install-tl # 设置环境变量 # LaTeX export TEX_HOME=/usr/local/texlive/2019 export PATH=$PATH:$TEX_HOME/bin/x86_64-linux export INFOPATH=$INFOPATH:$TEX_HOME/texmf-dist/doc/info export MANPATH=$MANPATH:$TEX_HOME/texmf-dist/doc/man  方法二 用docker安装\n# 拉取镜像 sudo docker pull ubuntu:18.04 sudo docker run -it --rm ubuntu:18.04 bash # 在镜像内操作 echo \u0026quot;deb http://mirrors.zju.edu.cn/ubuntu bionic main universe restricted multiverse deb http://mirrors.zju.edu.cn/ubuntu bionic-security main universe restricted multiverse deb http://mirrors.zju.edu.cn/ubuntu bionic-updates main universe restricted multiverse deb http://mirrors.zju.edu.cn/ubuntu bionic-backports main universe restricted multiverse deb-src http://mirrors.zju.edu.cn/ubuntu bionic main universe restricted multiverse deb-src http://mirrors.zju.edu.cn/ubuntu bionic-security main universe restricted multiverse deb-src http://mirrors.zju.edu.cn/ubuntu bionic-updates main universe restricted multiverse deb-src http://mirrors.zju.edu.cn/ubuntu bionic-backports main universe restricted multiverse\u0026quot; \u0026gt; /etc/apt/sources.list apt update # 安装texlive apt install texlive-full # 保存镜像 docker ps docker commit \u0026quot;刚刚安装的镜像\u0026quot; ubuntu-texlive # 将本地的 /home/x/tex 挂载到镜像中的 /latex 目录 docker run -it -v /home/x/tex:/latex ubuntu-latex /bin/bash  安装 Windows 字体 # 创建 win 下字体专用文件夹 sudo mkdir /usr/share/fonts/winfonts # 复制windows上的字体到/usr sudo cp your_winfonts_dir /usr/share/fonts/winfonts # 进入字体文件夹 cd /usr/share/fonts/winfonts # 修改访问权限 sudo chmod 744 * # 回到主目录 cd ~ # 更新字体信息 sudo mkfontscale sudo mkfontdir sudo fc-cache -f -v  More See detail in these websites.\nLaTeX模板\nLaTeX开源小屋\n","date":1587975168,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587975168,"objectID":"75b881dcb33092e405db4b74fe9a32a0","permalink":"http://lucas-wye.github.io/post/latex/","publishdate":"2020-04-27T16:12:48+08:00","relpermalink":"/post/latex/","section":"post","summary":"LaTeX（音译“拉泰赫”）是一种基于ΤΕΧ的排版系统","tags":[],"title":"LaTeX","type":"post"},{"authors":[],"categories":[],"content":" Shadowsocks（简称SS）是一種基於Socks5代理方式的加密傳輸协议，也可以指实现這個协议的各種开发包。 目前套件使用Python、C、C++、C#、Go语言、Rust等程式語言开发，大部分主要实现（iOS平台的除外）採用Apache许可证、GPL、MIT許可證等多種自由軟體許可協定開放原始碼。 Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端程序部署到服务器上面，然后通过客户端连接并建立本地代理。  Install # Ubuntu sudo apt install shadowsocks  使用 # 方法一 # Edit the configuration file sudo vim /etc/shadowsocks-libev/config.json # Edit the default configuration for debian sudo vim /etc/default/shadowsocks-libev # Start the service sudo /etc/init.d/shadowsocks-libev start ## or sudo systemctl start shadowsocks-libev # 方法二 ss-local -c /path/to/config.json  More See detail in these websites.\n安装教程\n配置浏览器\n","date":1587975005,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587975005,"objectID":"849edb7c871caa4df0bb2ed771ae5018","permalink":"http://lucas-wye.github.io/post/ss/","publishdate":"2020-04-27T16:10:05+08:00","relpermalink":"/post/ss/","section":"post","summary":"Shadowsocks（简称SS）是一種基於Socks5代理方式的加密傳輸协议，也可以指实现這個协议的各種开发包","tags":[],"title":"SS","type":"post"},{"authors":[],"categories":[],"content":" Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。 现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。  Install 从 此网站下载对应平台的编译器安装即可。\n设置国内代理 go env -w GOPROXY=https://goproxy.cn,direct  设置环境变量 # Golang export GO=... # 安装位置 export PATH=$PATH:$GO/bin export GOPATH=... # 指定一个本地位置 export PATH=$PATH:$GOPATH/bin  More See detail in these websites. go教程\ngo web教程\n","date":1587974907,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587974907,"objectID":"60564cfd3a9dbb4c59db353cf32079be","permalink":"http://lucas-wye.github.io/post/golang/","publishdate":"2020-04-27T16:08:27+08:00","relpermalink":"/post/golang/","section":"post","summary":"Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易","tags":[],"title":"Golang","type":"post"},{"authors":[],"categories":[],"content":" Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。 Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。 像 Perl 语言一样, Python 源代码同样遵循 GPL(GNU General Public License) 协议。  Install 从 清华镜像源下载对应平台的 anaconda/miniconda 安装即可。\n添加软件包下载镜像源 编辑~/.condarc文件\nchannels: - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - defaults show_channel_urls: true  conda创建python虚拟环境 # 查看当前存在哪些虚拟环境 conda env list conda info -e # 创建虚拟环境 conda create -n your_env_name python=X.X # 版本选择：2.7、3.6等 # 激活环境 conda activate your_env_name # 安装package到your_env_name conda install -n your_env_name [package] # 关闭虚拟环境 conda deactivate # 删除虚拟环境 conda remove -n your_env_name --all # 删除环境中的某个包 conda remove --name your_env_name package_name  常用包安装方法 # tensorflow conda install tensorflow # pytorch(CPU) conda install pytorch torchvision cpuonly -c pytorch ## 查看版本 import torch print(torch.__version__)  conda导出环境依赖 conda list -e \u0026gt; requirements.txt  Jupyter notebook 默认情况下，安装好 Anaconda 后打开 jupyter notebook, 访问本地 localhost:8888 即可。 但是如果要访问另一台机器，比如远端服务器上的 notebook, 即默认是不支持 ip addr:8888 的访问，需要额外配置。\n# 生成一个 notebook 配置文件 # 默认情况下,配置文件 ~/.jupyter/jupyter_notebook_config.py 并不存在 jupyter notebook --generate-config # 生成密码 jupyter notebook password # 修改配置文件 ～/.jupyter/jupyter_notebook_config.py c.NotebookApp.ip = '*' # 允许任何IP访问 c.NotebookApp.password = u'sha:...' # 密码的哈希值 c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 # 自行指定一个端口  添加多种环境 # 进入每个虚拟环境 conda activate env_name conda install ipykernel # 退出该虚拟环境 conda activate base # 然后再将这个kernal添加到jupyter里面，NAME为自己取的环境名字 python -m ipykernel install --user --name NAME --display-name \u0026quot;NAME\u0026quot; # 查看已有的kernels cd ~/.local/share/jupyter/kernels  pip # 导入依赖包 pip install -r requirements.txt # 只导出项目依赖包 pip install pipreqs pipreqs ./ # 导出依赖包 pip freeze \u0026gt; requirements.txt # 离线下载 pip download -d [DIR] -r requirements.txt # 离线安装 pip install --no-index --find-links=[DIR] -r requirements.txt # 更改镜像源 echo \u0026quot;[global]\\nindex-url = http://mirrors.aliyun.com/pypi/simple/\\n[install]\\ntrusted-host = mirrors.aliyun.com\u0026quot; \u0026gt; ~/.pip/pip.conf  More See detail in these websites.\nipynb文件在线查看工具\n","date":1587974743,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587974743,"objectID":"d220a608a8ad4324bff2f46915504c97","permalink":"http://lucas-wye.github.io/post/python/","publishdate":"2020-04-27T16:05:43+08:00","relpermalink":"/post/python/","section":"post","summary":"Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言","tags":[],"title":"Python","type":"post"},{"authors":[],"categories":[],"content":" Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权 使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机  Install # Ubuntu sudo apt-get install tmux # MacOS brew install tmux  基本操作 # 新建会话 tmux # 新建一个无名称的会话 tmux new -s demo # 新建一个名称为demo的会话 # 进入之前会话 tmux a # 默认进入第一个会话 tmux a -t demo # 进入到名称为demo的会话 # 离开会话 ctrl+b+d # 关闭会话 tmux kill-session -t demo # 关闭demo会话 tmux kill-server # 关闭服务器，所有的会话都将关闭 # 查看会话 tmux list-session # 查看所有会话 tmux ls # 查看所有会话，提倡使用简写形式 # 垂直分屏 ctrl+b+% # 水平分屏 ctrl+b+\\\u0026quot; # 根据按箭方向选择切换到某个pane。 ctrl+b+Up|Down|Left|Right # 滚屏 # 要进入copy-mode，即PREFIX+[，然后就可以用上下键来滚动屏幕，配置了vi快捷键模式， # 就可以像操作vi一样来滚动屏幕，非常的方便。退出直接按‘q’键即可。  More See detail in these websites.\nTmux使用手册\n","date":1587974655,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587974655,"objectID":"5d04ef8d30433cec4c23569542e473b1","permalink":"http://lucas-wye.github.io/post/tmux/","publishdate":"2020-04-27T16:04:15+08:00","relpermalink":"/post/tmux/","section":"post","summary":"Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权","tags":[],"title":"Tmux","type":"post"},{"authors":[],"categories":[],"content":" Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。 Java可运行于多个平台，如Windows, Mac OS，及其他多种UNIX版本的系统。  Install  下载JDK\nIntelliJ IDEA下载\n# 配置环境变量 export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144 # 这里换成自己的jdk目录 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH  Usage of adb(Android Debug) # 卸载系统软件 adb shell pm list package pm uninstall -k --user 0 package_name  ","date":1587974354,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587974354,"objectID":"0df67d4cfeb8f6fed55af4235c0f51ed","permalink":"http://lucas-wye.github.io/post/java/","publishdate":"2020-04-27T15:59:14+08:00","relpermalink":"/post/java/","section":"post","summary":"Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言","tags":[],"title":"Java","type":"post"},{"authors":[],"categories":[],"content":" 所有的 Unix Like 系统都会内建 Vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 Vim 编辑器。 Vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 Vim是从 Vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。简单的来说， Vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。  File Operation          :wq 存盘退出   :q! 退出不保存   :saveas [path/to/file] 另存为 [path/to/file]   :qa! 强行退出所有的正在编辑的文件   :bn 和 :bp 切换下一个或上一个文件   :w !sudo tee % 以sudo保存正在编辑的文件   :n move to next file   :rew 回到第一个文件   :edit [Filename] 打开新文件    Cursor movement          hjkl move   /[PATTERN] 搜索   ?[PATTERN] 搜索   % 匹配括号移动   f 搜索并移动到某个字符前   t 到某个字符前的第一个字符   :N 到第N行   gg 到第一行   G 到最后一行   [n] G go to last line or line [n]   w/W 到下一个单词的开头   e/E 到下一个单词的结尾   b 到上一个单词的开头   0 beginning of current line   $ end of current line   ^ beginning of text on current line   [CTRL] F/B move screen   [CTRL] D/U move half screen    Inserting text          i 前插入   a 后插入   I insert text at beginning of line   A append text at end of line   o 在当前行后插入一个新行   O 在当前行前插入一个新行    Deleting text          d 删除   D 删除当前行光标后所有内容   x 删当前光标的字符   X 删当前光标前的字符    Changing commands          u undo   [CTRL] r redo   . repeat last operation   p 后粘贴   P 前粘贴   y 复制   s/S substitute   ~ change case of character   J join current line and next line    Split windows          :split/vsplit 创建分屏   [CTRL] w + 方向 切换分屏    Command line mode          :![cmd] 暂时退出命令行执行cmd   :set all display all option settings   :[Addr/%]s/old expr/new string/[g] 替换当前行/Addr/%(文件内所有)的old expr为new string,[g]全局替换，否则只替换第一个 ｜   [CTRL] p/n 自动补齐   [CTRL] +/- 改变尺寸   v visual模式   V v-line模式   [CTRL] v v-block模式   :normal [Command] 可视化模式下执行命令   qa 录制宏   ci + \u0026quot; 删除引号之中的内容   tabe 打开新的标签页   +/-tabnext 切换标签页    Regular expression          ? match any single character at the indicated position   * match any string of zero or more characters   [abc\u0026hellip;] match any of the enclosed characters   [a-e] match any characters in the range a,b,c,d,e   [!def] match any characters not one of the enclosed characters, sh/bash   {abc,bcd,cde} match any set of characters separated by comma (,) (no spaces), bash/csh   ~ home directory of the current user, bash/csh   ~ user home directory of the specified user, bash/csh   . match any single character except newline   [^abc] match any character NOT in the enclosed set   ^exp regular expression must start at the beginning of the line   exp$ regular expression must end at the end of the line   \\ treat the next character literally 转义字符   xy*z xy开头，z结尾的字符串    Plug https://github.com/junegunn/vim-plug\n.vimrc  .vimrc\nNeoVim 使用Vim配置文件\nln -s ~/.vim ~/.config/nvim ln -s ~/.vimrc ~/.config/nvim/init.vim  More See detail in these websites.\nVi/Vim教程\n简明 VIM 练级攻略\n","date":1587972999,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587972999,"objectID":"60a65170037e2fa380c26ec80c791b2c","permalink":"http://lucas-wye.github.io/post/vi_vim/","publishdate":"2020-04-27T15:36:39+08:00","relpermalink":"/post/vi_vim/","section":"post","summary":"所有的 Unix Like 系统都会内建 Vi 文书编辑器","tags":[],"title":"Vi/Vim/NeoVim","type":"post"},{"authors":[],"categories":[],"content":" 收录了一些目前的常用网站 Here are some useful websites. Hope these will help you.  Repo https://zjusct.github.io/archives/\nhttps://pmpml.github.io/PMPML16/\nhttps://github.com/momodel/AIClub\nhttps://machine-learning-and-security.github.io/\nhttps://ying-zhang.github.io/misc/2016/we-love-paper/\nhttps://daiwk.github.io/posts/dl-federated-learning.html\nPaper https://arxiv.org/\nhttps://scholar.google.com/\nhttp://www.arxiv-sanity.com/\nhttp://scholar.chongbuluo.com\nhttp://libweb.zju.edu.cn/libweb/\nhttps://ieeexplore.ieee.org/Xplore/home.jsp\nhttps://paperpass.com/\nhttp://dsa.dayainfo.com/\nhttp://www.myhuiban.com/\nhttps://www.ccf.org.cn/xspj/gyml/\nhttp://jianying.space/conference-ranking.html\nhttp://faculty.cs.tamu.edu/guofei/sec_conf_stat.htm\n","date":1585297424,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585297424,"objectID":"50c5f0366dd809632c0e255ee6d27271","permalink":"http://lucas-wye.github.io/post/website/","publishdate":"2020-03-27T16:23:44+08:00","relpermalink":"/post/website/","section":"post","summary":"收录了一些目前的常用网站","tags":[],"title":"Website","type":"post"},{"authors":[],"categories":[],"content":" Kali Linux是基于Debian的Linux发行版， 设计用于数字取证操作系统。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版。 Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、John the Ripper，以及Aircrack-ng；用户可通过硬盘、live CD或live USB运行Kali Linux。Kali Linux既有32位和64位的镜像。可用于x86 指令集。同时还有基于ARM架构的镜像，可用于树莓派和三星的ARM Chromebook。  Install # 从Docker安装 docker pull kalilinux/kali-linux-docker # 运行 docker run -t -i kalilinux/kali-linux-docker /bin/bash  ###设置镜像源\n# 修改/etc/apt/source.list # 中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib # 阿里云 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib # 清华 deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free # 浙大 deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free # 官方源 deb http://http.kali.org/kali kali-rolling main non-free contrib deb-src http://http.kali.org/kali kali-rolling main non-free contrib deb http://mirrors.163.com/debian/ jessie main non-free contrib deb http://mirrors.163.com/debian/ jessie-updates main non-free contrib deb http://mirrors.163.com/debian/ jessie-backports main non-free contrib deb-src http://mirrors.163.com/debian/ jessie main non-free contrib deb-src http://mirrors.163.com/debian/ jessie-updates main non-free contrib deb-src http://mirrors.163.com/debian/ jessie-backports main non-free contrib deb http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib deb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib  More See detail in these websites.\nkali官网\n","date":1571212971,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587974571,"objectID":"d29205c5a4f0eb0d24ac800734bf9004","permalink":"http://lucas-wye.github.io/post/kali/","publishdate":"2019-10-16T16:02:51+08:00","relpermalink":"/post/kali/","section":"post","summary":"Kali Linux是基于Debian的Linux发行版， 设计用于数字取证操作系统","tags":[],"title":"Kali","type":"post"},{"authors":[],"categories":[],"content":" Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。  Install # Ubuntu curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh # 建立docker组 sudo groupadd docker # 将当前用户加入docker组 sudo usermod -aG docker $USER # 卸载本机所有的镜像、容器、卷以及配置文件 sudo rm -rf /var/lib/docker  基本命令 获取镜像\ndocker pull [user name]/[repo name]:[tag name]  Dockerfile example\n# Dockerfile创建镜像 FROM ubuntu:18.04 ENV LANG C.UTF-8 RUN echo \u0026quot;deb http://mirrors.zju.edu.cn/ubuntu bionic main universe restricted multiverse\\ndeb http://mirrors.zju.edu.cn/ubuntu bionic-security main universe restricted multiverse\\ndeb http://mirrors.zju.edu.cn/ubuntu bionic-updates main universe restricted multiverse\\ndeb http://mirrors.zju.edu.cn/ubuntu bionic-backports main universe restricted multiverse\\ndeb-src http://mirrors.zju.edu.cn/ubuntu bionic main universe restricted multiverse\\ndeb-src http://mirrors.zju.edu.cn/ubuntu bionic-security main universe restricted multiverse\\ndeb-src http://mirrors.zju.edu.cn/ubuntu bionic-updates main universe restricted multiverse\\ndeb-src http://mirrors.zju.edu.cn/ubuntu bionic-backports main universe restricted multiverse\u0026quot; \u0026gt; /etc/apt/sources.list # RUN ... # for pip # RUN echo \u0026quot;[global]\\nindex-url = http://mirrors.aliyun.com/pypi/simple/\\n[install]\\ntrusted-host = mirrors.aliyun.com\u0026quot; \u0026gt; ~/.pip/pip.conf # for conda # RUN echo \u0026quot;channels:\\n - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/\\n - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/\\n - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\\n - defaults\\nshow_channel_urls: true\u0026quot; \u0026gt; ~/.condarc  运行容器\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...] -i: 以交互模式运行容器，通常与 -t 同时使用 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用 -v: 绑定一个卷，格式为：本机绑定目录:容器内部绑定目录 -d: 后台运行容器，并返回容器ID -P: 随机端口映射，容器内部端口随机映射到主机的高端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项 --name: 对所新建容器进行命名 --rm: 容器终止后，自动删除容器文件  常用命令\n# 列出容器 docker container ls -a # 查看容器ID docker ps -a # 重新启动已被终止的指定容器 docker start [CONTAINER ID] # 终止容器 docker stop [CONTAINER NAME/ID] # 若是利用 -it 在容器内部进行操作，仅需输入 exit 即可 # 删除容器 docker kill [CONTAINER NAME/ID] # 若想将所有容器删除 docker container prune # 列出镜像 docker images # 重命名镜像 docker tag [old REPOSITORY]:[old TAG] or [IMAGE ID] [new REPOSITORY]:[new TAG] # 删除镜像 docker rmi [IMAGE] # 存出镜像 docker save -o [xx.tar] [REPOSITORY]:[TAG] # 载入镜像 sudo docker load --input [镜像文件] # 更新镜像 docker commit [OPTIONS] [IMAGE ID] [new REPOSITORY]:[new TAG] # -m: 提交的描述信息 # -a: 指定镜像作者  More See detail in these websites.\nDocker教程\nDocker学习笔记\n","date":1571212833,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587974433,"objectID":"127726cd63ae2ab246877595df44d1d3","permalink":"http://lucas-wye.github.io/post/docker/","publishdate":"2019-10-16T16:00:33+08:00","relpermalink":"/post/docker/","section":"post","summary":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中","tags":[],"title":"Docker","type":"post"},{"authors":[],"categories":[],"content":" GCC编译器也称为Linux GCC命令，它有很多选项。GCC编译器是Linux下最常用的编译器。  安装 # MacOS安装Xcode工具链 xcode-select --install # Ubuntu sudo apt install gcc  基本使用 gcc -c filename.c # compile only, produce .o gcc -g # compile for debugging gcc -o filename.o # gcc -O 1,2,3,4,s,fast # for optimization level gcc -Ipathname gcc -Dsymbol # define preprocessor symbol gcc -Ldirectory # add directory to the library search path gcc -lxyz # link with library libxyz.a or libxyz.so  gdb gdb BINARY_FILE list br 8 # breakpoint in line 8 run print value next where help quit  make (1)Predefined Macros\nAS - assembler (as) CC - C compiler command (cc) FC - Fortran compiler command (fc) CPP - C++ preprocessing command ($(CC) -E) CXX - C++ compiler command (g++) CFLAGS - C compiler option flags (e.g. -g) FFLAGS - Fortran compiler option flags (e.g. -g) LDFLAGS - Linking option flags (e.g. –L /usr/share/lib) LDLIBS – Linking libraries (e.g. -lm)  (2)Special Internal Macros\n$* # The basename of the current target $\u0026lt; # The name of a dependency file, as we see on last page $@ # The name of the current target. $? # The list of dependencies that are newer than the target.  More See detail in these websites.\nmore of gdb\n","date":1571212627,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587974227,"objectID":"3214588591155ecd68bdbcf4c8f49c35","permalink":"http://lucas-wye.github.io/post/gcc/","publishdate":"2019-10-16T15:57:07+08:00","relpermalink":"/post/gcc/","section":"post","summary":"GCC编译器也称为Linux GCC命令，它有很多选项。GCC编译器是Linux下最常用的编译器","tags":[],"title":"GCC","type":"post"},{"authors":[],"categories":[],"content":" Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。  git本地操作 (1)创建空仓库\ngit init  (2)添加文件\ngit add FILE_NAME git commit -m YOUR_COMMENT  (3)查看状态\ngit status  (4)版本回退\n# 上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本写成HEAD~100 git reset --hard HEAD^  (5)记录\ngit log # 当前分支 git reflog # 所有分支信息  (6)删除\nrm test.txt git rm test.txt  git远程 (1)创建远程\nssh-keygen -t rsa -C \u0026quot;YOUR_EMAIL\u0026quot; git config --global user.name \u0026quot;YOUR_NAME\u0026quot; git config --global user.email \u0026quot;YOUR_EMAIL\u0026quot;  (2)推送至github\ngit remote add origin git@github.com:xxx/xxx.git  (3)第一次推送\ngit push -u origin master  (4)后续推送\ngit push origin master  (5)克隆\ngit clone git@github.com:xxx/xxx.git  (6)拉取远程代码\n# 取回远程主机某个分支的更新，再与本地的指定分支合并 git pull \u0026lt;远程主机名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt;  (7)删除git项目所有提交历史\n# 创建新分支 git checkout --orphan latest_branch # 添加所有文件 git add . # commit代码 git commit -m YOUR_COMMENT # 删除原来的master分支 git branch -D master # 重命名为master git branch -m master # 推送到远程仓库 git push -f origin master  (8).git垃圾回收\nGit仓库越来越臃肿，大多数版本控制系统存储的是一组初始文件，以及每个文件随着时间的演进而逐步积累起来的差异；\n而Git则会把文件的每一个差异化版本都记录在案。这意味着，即使你只改动了某个文件的一行内容，Git也会生成一个全新的对象来存储新的文件内容。 对象碎片：如果你改动了一个很大的文件，git会为这个文件生成了一个很大的Blob对象\ncd .git du -ah # 查看文件大小 git gc --prune=now # 垃圾回收  实际上，并不需要手动调用 gc 命令。每当碎片对象过多，或者你向远端服务器发起推送的时候，git 就会自动执行一次打包过程。 (9)git更改远程库\n# 查询当前远程库 git remote -v # 更改远程库 git remote origin set-url \u0026lt;仓库地址\u0026gt;  submodule # 添加子仓库 git submodule add \u0026lt;仓库地址\u0026gt; \u0026lt;本地路径\u0026gt; # 检出子仓库 git submodule init # 初始化本地配置文件 git submodule update # 检出父仓库列出的commit ## 或者 git submodule update --init --recursive # 递归克隆 git clone \u0026lt;仓库地址\u0026gt; --recursive  More See detail in these websites.\ngit教程\n","date":1571211021,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587972621,"objectID":"4b21d5dcf3e4ccbf5460b69b359a5446","permalink":"http://lucas-wye.github.io/post/git/","publishdate":"2019-10-16T15:30:21+08:00","relpermalink":"/post/git/","section":"post","summary":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目","tags":[],"title":"Git","type":"post"},{"authors":[],"categories":[],"content":" Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。  Control Key [CTRL]U cancel line [CTRL]C cancel operation [CTRL]S pause display [CTRL]Q restart display [CTRL]A 光标移到行首 [CTRL]E 光标移到行末 [CTRL]K 清除至当前行尾 [CTRL]V treat following control character as normal character [Option]方向键 以单词为单位移动  User sudo adduser USERNAME # 添加root权限 sudo usermod -g sudo USERNAME # change password passwd # delete user sudo userdel -r USERNAME  Infomation who who am i whoami env alias man  File Maintenance # r = 4, w = 2, x = 1 chmod umask # set in startup files for the account to masks out permissions, umask numbers added to desired permission number equals 7. chgrp # change the group of the file chown # change the owner of a file # 查看当前目录文件大小 # (1)列出当前目录下每个文件的大小，同时也会给出当前目录下所有文件大小总和 ls -lht # (2)列出当前文件夹下所有文件对应的大小 du -sh PATH # 删除文件中的空行 cat YOUR_FILE | sed -e '/^$/d' # conditions -r return true (1) if it exists and is readable, otherwise return false (0) -w true if it exists and is writable -x true if it exists and is executable -f true if it exists and is a regular file (or for csh, exists and is not a directory) -d true if it exists and is a directory -e true if the file exists -o true if the user owns the file -z true if the file has zero length (empty) # 对Exfat文件系统支持 sudo apt install exfat-utils # 打包 tar -cvf YOUR_FILE.tar YOUR_FILE # 仅打包 tar -zcvf YOUR_FILE.tar.gz YOUR_FILE # gzip压缩 tar -jcvf YOUR_FILE.tar.bz2 YOUR_FILE # bzip2压缩 # 查看文件 tar -tvf YOUR_FILE.tar tar -ztvf YOUR_FILE.tar.gz tar -jtvf YOUR_FILE.tar.bz2 # 解包 tar -xvf YOUR_FILE.tar tar -zxvf YOUR_FILE.tar.gz tar -jxvf YOUR_FILE.tar.bz2  find and search # 查找24小时内修改过的文件 find ./ -mtime 0 # 查找当前目录及子目录中的.c文件 find . -name \u0026quot;*.c\u0026quot; # 查找当前目录符合条件的文件内容 grep -nHR \u0026quot;STRING\u0026quot; .  process ps ps -ef kill -9 PID  Bash executes order # login shell executes order: /etc/profile ~/.bash/_profile ~/.bash_login ~/.profile # non-login shell executes: /etc/bashrc ~/.bashrc  History history !598 # 执行第598条命令 sudo !! # 以root执行上一条命令 history | awk '{a[$2]++}END{for(i in a){print a[i] \u0026quot; \u0026quot; i}}' | sort -rn | head # 统计情况  CPU # 总核数 = 物理CPU个数 x 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 x 每颗物理CPU的核数 x 超线程数 # 物理CPU个数 cat /proc/cpuinfo| grep \u0026quot;physical id\u0026quot;| sort| uniq| wc -l # 每个物理CPU中core的个数(即核数) cat /proc/cpuinfo| grep \u0026quot;cpu cores\u0026quot;| uniq # 逻辑CPU的个数 cat /proc/cpuinfo| grep \u0026quot;processor\u0026quot;| wc -l # CPU型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # CPU的负载，返回1、5、15分钟内的负载情况 uptime  内存 cat /proc/meminfo free  磁盘 # 硬盘信息 fdisk -l # 查看磁盘IO的性能 iostat -x 10 # 挂载硬盘到某个文件夹 sudo mount /dev/sda YOUR_PATH # 查看硬盘挂载信息 df -h # 取消挂载 sudo umount YOUR_PATH  删除ppa源 cd /etc/apt/sources.list.d/ # 找到关于源的文件,删除即可  查看中文字体 fc-list:lang=zh-cn  I/O Redirection and Piping # stdin: 0, stdout: 1, stderr: 2 | 管道 \u0026gt; stdout重定向到file \u0026gt;\u0026gt; stdout重定向到file(不覆盖) \u0026lt; stdin从file重定向 tee 复制stdout \u0026gt;/dev/null 直接扔掉stdout 1\u0026gt;FILE_1 2\u0026gt;FILE_2 stdout to FILE_1, stderr to FILE_2 \u0026gt;FILE 2\u0026gt;\u0026amp;1 redirect stdout and stderr to FILE 2\u0026gt;\u0026amp;1 | tee 将stderr和stdout输出到文件的同时在屏幕上输出  开机进入命令行 sudo systemctl set-default multi.user # 进入命令行 sudo systemctl set-default graph... # 进入图形界面  terminal设置代理 # MacOS: 1087, other: 1080 export http_proxy=http://127.0.0.1:1087 export https_proxy=http://127.0.0.1:1087  Ubuntu设置窗口键在左侧 gsettings set org.gnome.desktop.wm.preferences button-layout 'close,minimize,maximize:'  生成强密码 openssl rand -base64 NUMBER  terminal output to clip  Windows: clip MacOS: pbcopy, pbpaste Linux: xsel  ","date":1571210362,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587971962,"objectID":"54ce59e82bed1ddb5d9b00e20a4cd5da","permalink":"http://lucas-wye.github.io/post/linux/","publishdate":"2019-10-16T15:19:22+08:00","relpermalink":"/post/linux/","section":"post","summary":"inux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统","tags":[],"title":"Linux","type":"post"},{"authors":[],"categories":[],"content":" OpenMP是由OpenMP Architecture Review Board牵头提出的，并已被广泛接受的，用于共享内存并行系统的多线程程序设计的一套编译指令 (Compiler Directive)。  Introduction See detail at wiki.\nOpenMP Programming Example Here is a C program using OpenMP.\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;omp.h\u0026gt; int main(void) { const int n = 10; int arr[n]; #pragma omp parallel for for(int i = 0;i \u0026lt; n;i++) { arr[i] = i; printf(\u0026quot;%d\\n\u0026quot;,i); } for(int j = 0;j \u0026lt; n;j++){ printf(\u0026quot;%d\\n\u0026quot;,arr[j]); } return 0; }  More Example See detail in these websites.\nOpenMP并行开发（C++） \nOpenMP并行程序设计（二）\n","date":1570172605,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587971005,"objectID":"440068f2cb104be6f0321c1ec854ab6d","permalink":"http://lucas-wye.github.io/post/openmp/","publishdate":"2019-10-04T15:03:25+08:00","relpermalink":"/post/openmp/","section":"post","summary":"OpenMP是由OpenMP Architecture Review Board牵头提出的，并已被广泛接受的，用于共享内存并行系统的多线程程序设计的一套编译指令 (Compiler Directive)","tags":[],"title":"OpenMP","type":"post"}]